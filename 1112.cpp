#include <iostream>
using namespace std;

int main()
{
	//вводим число отрезков и сами отрезки
	int n;
	cin >> n;
	int otrezki[2][99];
	for (int i = 0; i < n; i++)
		cin >> otrezki[0][i] >> otrezki[1][i];

	//введём перемнные для хранения ответа
	int m = 0;
	int otvet[2][99];

	/*найдём отрезок с минимальной правой границей
	этот отрезок всегда будет в ответе
	если с ним пересекаются другие отрезки
	значит им всем принадлежит как минимум правый единичный подотрезок этого отрезка
	значит из всех эти отрезков только один может быть в ответе
	при этом все отрезки кроме этого могут иметь и другие пересечения
	значит ответ с этим отрезком будет максиамльным*/

	otvet[0][m] = otrezki[0][0];
	otvet[1][m] = otrezki[1][0];
	for (int i = 1; i < n; i++)
		if (otvet[1][m] > otrezki[1][i])
		{
			otvet[0][m] = otrezki[0][i];
			otvet[1][m] = otrezki[1][i];
		}
	m++;

	/*имея стартовый отрезок, будем искать следующие
	так чтобы они не пересекались с текщим
	из подобных будем выбирать с наименьшей правой границей*/

	int noviy_l, noviy_r;
	while (true)
	{
		noviy_l = 0;
		noviy_r = 1000;
		for (int i = 0; i < n; i++)
		{
			//проверяем что отрезок лежит справа от текущего и не пересекается с ним
			if (otvet[1][m - 1] > otrezki[0][i])
				continue;
			//проверяем что правая граница больше, чем у найденного ранее
			if (noviy_r < otrezki[1][i])
				continue;
			//записываем отрезок как выбраный
			noviy_l = otrezki[0][i];
			noviy_r = otrezki[1][i];
		}
		/*проверяем что нам удалось найти новый отрезок
		если нет, значит задача решена, больше подходящих отрезков нет*/
		if (noviy_r == 1000)
			break;
		//записываем новый отрезок в ответ
		otvet[0][m] = noviy_l;
		otvet[1][m] = noviy_r;
		m++;
	}

	//выводим ответ
	cout << m << endl;
	for (int i = 0; i < m; i++)
		cout << otvet[0][i] << ' ' << otvet[1][i] << endl;

	return 0;
}